{
  "blog": [
    {
      "title": "Flutter for Beginner",
      "description": "Flutter is used cross development",
      "content": "as dkajbdakjdsabasbabsduabsdbasdbabdd",
      "author": "James Bond",
      "id": 1
    },
    {
      "title": "hello",
      "description": "des",
      "content": "Vue is a framework and ecosystem that covers most of the common features needed in frontend development. But the web is extremely diverse - the things we build on the web may vary drastically in form and scale. With that in mind, Vue is designed to be flexible and incrementally adoptable. Depending on your use case, Vue can be used in different ways:\n\nEnhancing static HTML without a build step\nEmbedding as Web Components on any page\nSingle-Page Application (SPA)\nFullstack / Server-Side Rendering (SSR)\nJamstack / Static Site Generation (SSG)\nTargeting desktop, mobile, WebGL, and even the terminal\nIf you find these concepts intimidating, don't worry! The tutorial and guide only require basic HTML and JavaScript knowledge, and you should be able to follow along without being an expert in any of these.\n\nIf you are an experienced developer interested in how to best integrate Vue into your stack, or you are curious about what these terms mean, we discuss them in more details in Ways of Using Vue.\n\nDespite the flexibility, the core knowledge about how Vue works is shared across all these use cases. Even if you are just a beginner now, the knowledge gained along the way will stay useful as you grow to tackle more ambitious goals in the future. If you are a veteran, you can pick the optimal way to leverage Vue based on the problems you are trying to solve, while retaining the same productivity. This is why we call Vue \"The Progressive Framework\": it's a framework that can grow with you and adapt to your needs.\n\nSingle-File Components#\nIn most build-tool-enabled Vue projects, we author Vue components using an HTML-like file format called Single-File Component (also known as *.vue files, abbreviated as SFC). A Vue SFC, as the name suggests, encapsulates the component's logic (JavaScript), template (HTML), and styles (CSS) in a single file. Here's the previous example, written in SFC format:\n\nvue\n<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">Count is: {{ count }}</button>\n</template>\n\n<style scoped>\nbutton {\n  font-weight: bold;\n}\n</style>\nSFC is a defining feature of Vue, and is the recommended way to author Vue components if your use case warrants a build setup. You can learn more about the how and why of SFC in its dedicated section - but for now, just know that Vue will handle all the build tools setup for you.\n\nAPI Styles#\nVue components can be authored in two different API styles: Options API and Composition API.\n\nOptions API#\nWith Options API, we define a component's logic using an object of options such as data, methods, and mounted. Properties defined by options are exposed on this inside functions, which points to the component instance:\n\nvue\n<script>\nexport default {\n  // Properties returned from data() become reactive state\n  // and will be exposed on `this`.\n  data() {\n    return {\n      count: 0\n    }\n  },\n\n  // Methods are functions that mutate state and trigger updates.\n  // They can be bound as event listeners in templates.\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n\n  // Lifecycle hooks are called at different stages\n  // of a component's lifecycle.\n  // This function will be called when the component is mounted.\n  mounted() {\n    console.log(`The initial count is ${this.count}.`)\n  }\n}\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\nTry it in the Playground\n\nComposition API#\nWith Composition API, we define a component's logic using imported API functions. In SFCs, Composition API is typically used with <script setup>. The setup attribute is a hint that makes Vue perform compile-time transforms that allow us to use Composition API with less boilerplate. For example, imports and top-level variables / functions declared in <script setup> are directly usable in the template.\n\nHere is the same component, with the exact same template, but using Composition API and <script setup> instead:\n\nvue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// reactive state\nconst count = ref(0)\n\n// functions that mutate state and trigger updates\nfunction increment() {\n  count.value++\n}\n\n// lifecycle hooks\nonMounted(() => {\n  console.log(`The initial coun",
      "author": "Vue Docs",
      "id": 3
    }
  ]
}